---
layout: lecture
title: "包管理和依赖管理"
presenter: Anish
video:
  aspect: 56.25
  id: tgvt473T8xA
---

软件通常是建立在其他软件（集合）的基础上构建的，这就需要进行依赖管理。

包/依赖管理程序是针对特定语言的，但许多共享通用的思想。

## 包仓库

包托管在**包仓库**中。不同的语言有不同的仓库（有时对于特定语言可能有多个），比如 [PyPI](https://pypi.org/) 用于 Python，[RubyGems](https://rubygems.org/) 用于 Ruby，[crates.io](https://crates.io/) 用于 Rust。它们通常存储所有版本的软件（源代码以及针对特定平台的预编译二进制文件）。

## 语义化版本

软件随时间而演变，我们需要一种方式来引用软件版本。一些简单的方式可能是使用序列号或提交哈希来引用软件，但我们可以通过使用版本号来传达更多信息来提高通信的效率。

有许多方法；其中一种流行的方法是 [语义化版本](https://semver.org/)：

```plaintext
x.y.z
^ ^ ^
| | +- 补丁版本
| +--- 次要版本
+----- 主要版本
```

增加主要版本（major）当你进行不兼容的 API 更改时。

增加次要版本（minor）当你以向后兼容的方式添加功能时。

增加补丁版本（patch）当你进行向后兼容的错误修复时。

例如，如果你依赖于某个软件的 `v1.2.0` 版本引入的功能，那么你可以安装任何 `v1.x.y` 版本，其中次要版本 `x >= 2`，并且补丁版本 `y`。你需要安装主要版本 `1`（因为 `2` 可能会引入向后不兼容的更改），并且你需要安装次要版本 `>= 2`（因为你依赖于该次要版本引入的功能）。你可以使用任何更新的次要版本或补丁版本，因为它们不应该引入任何向后不兼容的更改。

## 锁文件

除了指定版本外，为了防止篡改，强制确保依赖项的 _内容_ 未更改也是很好的。一些工具使用 _锁文件_ 来指定依赖项的密码哈希（以及版本），并在包安装时进行检查。

## 指定版本

工具通常让你以多种方式指定版本，例如：

- 精确版本，例如 `2.3.12`
- 最小主要版本，例如 `>= 2`
- 指定主要版本和最小补丁版本，例如 `>= 2.3, <3.0`

指定精确版本可以避免根据安装的依赖项产生不同的行为（如果所有依赖项都忠实地遵循语义化版本规范，这不应该发生，但有时人们会犯错）。指定最小要求的优点是允许安装错误修复（例如补丁升级）。

## 依赖解决

包管理器使用各种依赖解决算法来满足依赖关系要求。在处理复杂的依赖关系时，这通常会变得很具有挑战性（例如，一个包可以被多个顶级依赖项间接依赖，并且可能需要不同的版本）。不同的包管理器在依赖解决方面具有不同程度的复杂性，但这是需要注意的问题：如果你正在调试依赖关系，你可能需要了解这一点。

## 虚拟环境

如果你正在开发多个软件项目，它们可能依赖于特定软件的不同版本。有时，你的构建工具会自然地处理这个问题（例如通过构建一个静态二进制文件）。

对于其他构建工具和编程语言，一种方法是使用虚拟环境来处理这个问题（例如，对于 Python，可以使用 [virtualenv](https://docs.python-guide.org/dev/virtualenvs/) 工具）。你可以在虚拟环境中为每个项目安装依赖项，而不是在系统范围内安装依赖项，并在你为特定项目工作时 _激活_ 你想要使用的虚拟环境。

## 销售商

另一种非常不同的依赖管理方法是 _销售商_。与使用依赖管理器或构建工具获取软件不同，你将依赖项的整个源代码复制到软件的存储库中。这样做的优点是，你始终在相同版本的依赖项上构建，并且不需要依赖包存储库，但是升级依赖项需要更多的工作。
